"""Monitoring and Observation Framework.

Provides extensible pattern matching and alerting:
- Event observation
- Pattern detection
- Alert rules and notifications
"""

from abc import ABC, abstractmethod
from typing import Optional, Callable, Any, Iterator
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import re
import asyncio
import json


class AlertSeverity(str, Enum):
    """Alert severity levels."""
    
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertStatus(str, Enum):
    """Alert status states."""
    
    NEW = "new"
    ACKNOWLEDGED = "acknowledged"
    INVESTIGATING = "investigating"
    RESOLVED = "resolved"
    FALSE_POSITIVE = "false_positive"


@dataclass
class ObservationEvent:
    """A single observation from monitoring.
    
    Generic event structure for any monitored activity.
    """
    
    id: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    source: str = ""  # Where the observation came from
    event_type: str = ""  # Type of event
    data: dict = field(default_factory=dict)  # Event-specific data
    tags: set[str] = field(default_factory=set)
    metadata: dict = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "source": self.source,
            "event_type": self.event_type,
            "data": self.data,
            "tags": list(self.tags),
        }
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a value from event data."""
        return self.data.get(key, default)


@dataclass
class Alert:
    """An alert generated by pattern matching.
    
    Represents a notable event requiring attention.
    """
    
    id: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    severity: AlertSeverity = AlertSeverity.MEDIUM
    status: AlertStatus = AlertStatus.NEW
    title: str = ""
    description: str = ""
    rule_name: str = ""  # Which rule triggered this
    source_events: list[str] = field(default_factory=list)  # Event IDs
    assigned_to: Optional[str] = None
    resolved_at: Optional[datetime] = None
    metadata: dict = field(default_factory=dict)
    
    def acknowledge(self, by: Optional[str] = None) -> None:
        """Acknowledge this alert."""
        self.status = AlertStatus.ACKNOWLEDGED
        self.assigned_to = by
    
    def resolve(self) -> None:
        """Mark alert as resolved."""
        self.status = AlertStatus.RESOLVED
        self.resolved_at = datetime.now()
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "severity": self.severity.value,
            "status": self.status.value,
            "title": self.title,
            "description": self.description,
            "rule_name": self.rule_name,
        }


class PatternMatcher(ABC):
    """Abstract base for pattern matching on events."""
    
    @abstractmethod
    def matches(self, event: ObservationEvent) -> bool:
        """Check if an event matches this pattern.
        
        Args:
            event: Event to check.
        
        Returns:
            bool: True if matches.
        """
        pass


class FieldMatcher(PatternMatcher):
    """Match events by field values.
    
    Example:
        >>> matcher = FieldMatcher(event_type="login", outcome="failure")
    """
    
    def __init__(self, **conditions) -> None:
        """Initialize with field conditions."""
        self.conditions = conditions
    
    def matches(self, event: ObservationEvent) -> bool:
        for field, expected in self.conditions.items():
            # Check direct attributes
            if hasattr(event, field):
                actual = getattr(event, field)
            else:
                # Check in data dict
                actual = event.data.get(field)
            
            if actual != expected:
                return False
        
        return True


class RegexMatcher(PatternMatcher):
    """Match events using regex patterns.
    
    Example:
        >>> matcher = RegexMatcher(field="message", pattern=r"error.*failed")
    """
    
    def __init__(self, field: str, pattern: str) -> None:
        self.field = field
        self.pattern = re.compile(pattern, re.IGNORECASE)
    
    def matches(self, event: ObservationEvent) -> bool:
        value = event.data.get(self.field, "")
        if isinstance(value, str):
            return bool(self.pattern.search(value))
        return False


class ThresholdMatcher(PatternMatcher):
    """Match when a value exceeds a threshold.
    
    Example:
        >>> matcher = ThresholdMatcher(field="attempts", threshold=5)
    """
    
    def __init__(
        self,
        field: str,
        threshold: float,
        comparison: str = "gt"  # gt, lt, gte, lte, eq
    ) -> None:
        self.field = field
        self.threshold = threshold
        self.comparison = comparison
    
    def matches(self, event: ObservationEvent) -> bool:
        value = event.data.get(self.field)
        if value is None:
            return False
        
        try:
            value = float(value)
        except (ValueError, TypeError):
            return False
        
        comparisons = {
            "gt": value > self.threshold,
            "lt": value < self.threshold,
            "gte": value >= self.threshold,
            "lte": value <= self.threshold,
            "eq": value == self.threshold,
        }
        
        return comparisons.get(self.comparison, False)


class AggregationMatcher(PatternMatcher):
    """Match based on event aggregation over time.
    
    Detects patterns like "more than 5 failed logins in 5 minutes".
    
    Example:
        >>> matcher = AggregationMatcher(
        ...     window_minutes=5,
        ...     threshold=5,
        ...     group_by="user_id"
        ... )
    """
    
    def __init__(
        self,
        window_minutes: int,
        threshold: int,
        group_by: Optional[str] = None,
        event_filter: Optional[PatternMatcher] = None,
    ) -> None:
        self.window = timedelta(minutes=window_minutes)
        self.threshold = threshold
        self.group_by = group_by
        self.event_filter = event_filter
        self._buckets: dict[str, list[datetime]] = {}
    
    def matches(self, event: ObservationEvent) -> bool:
        # Apply event filter if set
        if self.event_filter and not self.event_filter.matches(event):
            return False
        
        # Get bucket key
        if self.group_by:
            key = str(event.data.get(self.group_by, "default"))
        else:
            key = "default"
        
        # Add to bucket
        now = datetime.now()
        if key not in self._buckets:
            self._buckets[key] = []
        self._buckets[key].append(now)
        
        # Clean old entries
        cutoff = now - self.window
        self._buckets[key] = [t for t in self._buckets[key] if t > cutoff]
        
        # Check threshold
        return len(self._buckets[key]) >= self.threshold


@dataclass
class AlertRule:
    """A rule that generates alerts when patterns match.
    
    Example:
        >>> rule = AlertRule(
        ...     name="brute_force",
        ...     matcher=AggregationMatcher(window_minutes=5, threshold=10),
        ...     severity=AlertSeverity.HIGH,
        ... )
    """
    
    name: str
    matcher: PatternMatcher
    severity: AlertSeverity = AlertSeverity.MEDIUM
    title_template: str = "Alert: {rule_name}"
    description_template: str = ""
    enabled: bool = True
    cooldown_minutes: int = 5  # Minimum time between alerts
    metadata: dict = field(default_factory=dict)
    
    _last_alert: Optional[datetime] = field(default=None, repr=False)
    
    def check(self, event: ObservationEvent) -> Optional[Alert]:
        """Check if this rule triggers on an event.
        
        Args:
            event: Event to check.
        
        Returns:
            Alert or None.
        """
        if not self.enabled:
            return None
        
        # Check cooldown
        now = datetime.now()
        if self._last_alert:
            if now - self._last_alert < timedelta(minutes=self.cooldown_minutes):
                return None
        
        # Check pattern
        if not self.matcher.matches(event):
            return None
        
        # Generate alert
        self._last_alert = now
        
        return Alert(
            id=f"alert-{now.timestamp()}",
            severity=self.severity,
            title=self.title_template.format(rule_name=self.name, **event.data),
            description=self.description_template.format(**event.data),
            rule_name=self.name,
            source_events=[event.id],
        )


class Observer:
    """Observer interface for receiving events."""
    
    def on_event(self, event: ObservationEvent) -> None:
        """Handle an observation event."""
        pass
    
    def on_alert(self, alert: Alert) -> None:
        """Handle a generated alert."""
        pass


class MonitoringService:
    """Central monitoring service.
    
    Processes events, evaluates rules, and dispatches alerts.
    
    Example:
        >>> service = MonitoringService()
        >>> service.add_rule(brute_force_rule)
        >>> service.process(event)
    """
    
    def __init__(self) -> None:
        """Initialize monitoring service."""
        self._rules: list[AlertRule] = []
        self._observers: list[Observer] = []
        self._alerts: list[Alert] = []
        self._event_queue: asyncio.Queue = asyncio.Queue()
        self._running = False
    
    def add_rule(self, rule: AlertRule) -> None:
        """Add an alert rule."""
        self._rules.append(rule)
    
    def remove_rule(self, name: str) -> bool:
        """Remove a rule by name."""
        for i, rule in enumerate(self._rules):
            if rule.name == name:
                self._rules.pop(i)
                return True
        return False
    
    def add_observer(self, observer: Observer) -> None:
        """Add an observer."""
        self._observers.append(observer)
    
    def process(self, event: ObservationEvent) -> list[Alert]:
        """Process an event through all rules.
        
        Args:
            event: Event to process.
        
        Returns:
            list: Generated alerts.
        """
        alerts = []
        
        # Notify observers
        for observer in self._observers:
            try:
                observer.on_event(event)
            except Exception:
                pass
        
        # Check rules
        for rule in self._rules:
            alert = rule.check(event)
            if alert:
                alerts.append(alert)
                self._alerts.append(alert)
                
                # Notify observers of alert
                for observer in self._observers:
                    try:
                        observer.on_alert(alert)
                    except Exception:
                        pass
        
        return alerts
    
    async def start(self) -> None:
        """Start the async monitoring loop."""
        self._running = True
        
        while self._running:
            try:
                event = await asyncio.wait_for(
                    self._event_queue.get(),
                    timeout=1.0
                )
                self.process(event)
            except asyncio.TimeoutError:
                continue
    
    async def stop(self) -> None:
        """Stop the monitoring loop."""
        self._running = False
    
    async def submit(self, event: ObservationEvent) -> None:
        """Submit an event for async processing."""
        await self._event_queue.put(event)
    
    def get_alerts(
        self,
        status: Optional[AlertStatus] = None,
        severity: Optional[AlertSeverity] = None,
        limit: int = 100,
    ) -> list[Alert]:
        """Get alerts with optional filtering."""
        results = []
        
        for alert in reversed(self._alerts):
            if status and alert.status != status:
                continue
            if severity and alert.severity != severity:
                continue
            results.append(alert)
            if len(results) >= limit:
                break
        
        return results
    
    @property
    def alert_count(self) -> int:
        return len(self._alerts)
    
    @property
    def active_alert_count(self) -> int:
        return sum(1 for a in self._alerts if a.status == AlertStatus.NEW)
